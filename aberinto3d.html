<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laberinto 3D - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Variables globales
        let scene, camera, renderer, controls;
        let maze = [];
        const mazeSize = 23;
        
        // Inicialización
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);
            
            // Crear cámara perspectiva
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 18);
            
            // Configurar renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Controles de órbita
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Añadir luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            // Crear laberinto básico
            generateMaze();
            renderMaze();
            
            // Añadir plano como suelo
            const planeGeometry = new THREE.PlaneGeometry(30, 30);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.5;
            scene.add(plane);
            
            // Iniciar animación
            animate();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
        }
        
        // Generar estructura básica del laberinto
        function generateMaze() {
            // Inicializar matriz del laberinto
            for (let i = 0; i < mazeSize; i++) {
                maze[i] = [];
                for (let j = 0; j < mazeSize; j++) {
                    // Crear paredes en los bordes y patrón simple
                    maze[i][j] = (i === 0 || j === 0 || i === mazeSize-1 || j === mazeSize-1 || 
                                 (i % 2 === 0 && j % 2 === 0)) ? 1 : 0;
                }
            }
            
            // Añadir entrada y salida
            maze[1][0] = 0;
            maze[mazeSize-2][mazeSize-1] = 0;
        }
        
        // Renderizar el laberinto en 3D
        function renderMaze() {
            const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
            
            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    if (maze[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(i - mazeSize/2, 0.5, j - mazeSize/2);
                        scene.add(wall);
                    }
                }
            }
        }
        
        // Animación
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Ajustar tamaño en resize de ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Iniciar la aplicación
        init();
    </script>
</body>
</html>